<!DOCTYPE html>
<html class="no-js" lang="zh-cn">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>如何通过命令行批量下载文件 - TecX</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta property="og:title" content="如何通过命令行批量下载文件" />
<meta property="og:description" content="项目中经常需要将网络链接批量下载成文件，经过使用软件和编写代码都可以达成同样的目的，但经过尝试，推荐一个在mac上最方便且稳定的方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/bash_txt/" />
<meta property="article:published_time" content="2018-12-31T00:00:00+00:00" />
<meta property="article:modified_time" content="2018-12-31T00:00:00+00:00" />

	<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="如何通过命令行批量下载文件"/>
<meta name="twitter:description" content="项目中经常需要将网络链接批量下载成文件，经过使用软件和编写代码都可以达成同样的目的，但经过尝试，推荐一个在mac上最方便且稳定的方法。"/>

	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/custom.css">
	<link rel="shortcut icon" href="/favicon.ico">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-149339844-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container">
		<div class="logo">
			<a class="logo__link" href="/" title="TecX" rel="home">
				<div class="logo__title">TecX</div>
				<div class="logo__tagline">编程/设计/数据/可视化</div>
			</a>
		</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何通过命令行批量下载文件</h1>
			<div class="post__meta meta">
<div class="meta__item-datetime meta__item">
	<svg class="meta__icon icon icon-time" width="16" height="14" viewBox="0 0 30 28"><path d="M15 0C7 0 1 6 1 14s6 14 14 14 14-6 14-14S23 0 15 0zm0 25C9 25 4 20 4 14S9 3 15 3s11 5 11 11-5 11-11 11zm1-18h-2v8.4l6.8 4.4L22 18l-6-3.8V7z"/></svg>
	<time class="meta__text" datetime="2018-12-31T00:00:00">December 31, 2018</time>
</div>

<div class="meta__item-categories meta__item">
	<svg class="meta__icon icon icon-category" width="16" height="16" viewBox="0 0 16 16"><path d="m7 2l1 2h8v11h-16v-13z"/></svg>
	<span class="meta__text"><a class="meta__link" href="/categories/system" rel="category">system</a></span>
</div>
</div>
		</header>
<div class="post__toc toc">
	<div class="toc__title">目录</div>
	<div class="toc__menu">
		<nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#wget">wget</a>
<ul>
<li><a href="#批量下载方法">批量下载方法</a></li>
<li><a href="#剪切">剪切</a></li>
<li><a href="#复制">复制</a></li>
<li><a href="#重命名">重命名</a></li>
<li><a href="#合并文件">合并文件</a></li>
<li><a href="#分割文件">分割文件</a></li>
<li><a href="#查看文件编码">查看文件编码</a></li>
<li><a href="#postgres-localhost-报错">postgres localhost 报错！！！</a></li>
<li><a href="#find">find</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
	</div>
</div>
<div class="content post__content clearfix">
			<p>项目中经常需要将网络链接批量下载成文件，经过使用软件和编写代码都可以达成同样的目的，但经过尝试，推荐一个在mac上最方便且稳定的方法。</p>

<h2 id="wget">wget</h2>

<p>wget命令用来从指定的URL下载文件，更多用法 参见<a href="https://man.linuxde.net/wget">https://man.linuxde.net/wget</a></p>

<h3 id="批量下载方法">批量下载方法</h3>

<p>将下载链接的地址存在url.txt，使用换行分割
进入同级目录，</p>

<pre><code>wget -i url.txt
</code></pre>

<p>其中，-i是下载选项，用于从指定文件获取要下载的URL地址。</p>

<h3 id="剪切">剪切</h3>

<p>mv a/a.jpg b/a.jpg
mv /home/ujtidusu
city.json</p>

<h3 id="复制">复制</h3>

<p>cp a/a.jpg b/a.jpg</p>

<h3 id="重命名">重命名</h3>

<p>rename命令</p>

<pre><code>#1
rename 's/js/txt/' *.js
</code></pre>

<h3 id="合并文件">合并文件</h3>

<pre><code>cat *.txt &gt; merge.txt
</code></pre>

<h3 id="分割文件">分割文件</h3>

<p>-a 后缀长度
-l 行数
改两处ff_ 替换文件名</p>

<pre><code>split -l 500000 -a 4 flickr_sh_1000.txt ff_&amp;&amp;ls|grep ff_|xargs -n1 -i{} mv {} {}.txt
</code></pre>

<h3 id="查看文件编码">查看文件编码</h3>

<pre><code>file -b /etc/hosts
</code></pre>

<h3 id="postgres-localhost-报错">postgres localhost 报错！！！</h3>

<pre><code># 修改文件编码
iconv -f UTF-16 -t ASCII /Users/uj/Desktop/hosts &gt; /Users/uj/Desktop/hosts2
</code></pre>

<pre><code class="language-bash"># 打开环境变量
open -e ~/.bash_profile
# 使修改生效
source  ~/.bash_profile
# 查看是否生效
echo $PATH

### 安装配置phantomjs
# 环境变量中加入
export PATH=/Applications/phantomjs-2.1.1-macosx/bin:$PATH
# 查看是否成功
phantomjs --version

# phantomjs安装出错
ValueError: Invalid configuration:
  - Deprecated option 'domaincontroller': use 'http_authenticator.domain_controller' instead.
  
python -m pip install wsgidav==2.4.1

# 查看端口占用
lsof -i:25555
# 查看当前所有监听的端口以及对应的Command和PID
lsof -nP -iTCP -sTCP:LISTEN
# 查看指定端口对应的Command和PID 
lsof -nP -iTCP:4000 -sTCP:LISTEN

-n 表示不显示主机名
-P 表示不显示端口俗称
不加 sudo 只能查看以当前用户运行的程序
sudo lsof -nP -iTCP -sTCP:LISTEN
# 杀死进程
sudo kill -9 7748
</code></pre>

<h3 id="find">find</h3>

<p>find /Volumes/hdd/data/111 -iname &ldquo;*.jp*g&rdquo;</p>

<pre><code>根据文件或者正则表达式进行匹配
列出当前目录及子目录下所有文件和文件夹

find .
在/home目录下查找以.txt结尾的文件名

find /home -name &quot;*.txt&quot;
同上，但忽略大小写

find /home -iname &quot;*.txt&quot;
当前目录及子目录下查找所有以.txt和.pdf结尾的文件

find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)

或

find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; 
匹配文件路径或者文件

find /usr/ -path &quot;*local*&quot;
基于正则表达式匹配文件路径

find . -regex &quot;.*\(\.txt\|\.pdf\)$&quot;
同上，但忽略大小写

find . -iregex &quot;.*\(\.txt\|\.pdf\)$&quot;
否定参数
找出/home下不是以.txt结尾的文件

find /home ! -name &quot;*.txt&quot;
根据文件类型进行搜索
find . -type 类型参数
类型参数列表：

f 普通文件
l 符号连接
d 目录
c 字符设备
b 块设备
s 套接字
p Fifo
基于目录深度搜索
向下最大深度限制为3

find . -maxdepth 3 -type f
搜索出深度距离当前目录至少2个子目录的所有文件

find . -mindepth 2 -type f
根据文件时间戳进行搜索
find . -type f 时间戳
UNIX/Linux文件系统每个文件都有三种时间戳：

访问时间（-atime/天，-amin/分钟）：用户最近一次访问时间。
修改时间（-mtime/天，-mmin/分钟）：文件最后一次修改时间。
变化时间（-ctime/天，-cmin/分钟）：文件数据元（例如权限等）最后一次修改时间。
搜索最近七天内被访问过的所有文件

find . -type f -atime -7
搜索恰好在七天前被访问过的所有文件

find . -type f -atime 7
搜索超过七天内被访问过的所有文件

find . -type f -atime +7
搜索访问时间超过10分钟的所有文件

find . -type f -amin +10
找出比file.log修改时间更长的所有文件

find . -type f -newer file.log
根据文件大小进行匹配
find . -type f -size 文件大小单元
文件大小单元：

b —— 块（512字节）
c —— 字节
w —— 字（2字节）
k —— 千字节
M —— 兆字节
G —— 吉字节
搜索大于10KB的文件

find . -type f -size +10k
搜索小于10KB的文件

find . -type f -size -10k
搜索等于10KB的文件

find . -type f -size 10k
删除匹配文件
删除当前目录下所有.txt文件

find . -type f -name &quot;*.txt&quot; -delete
根据文件权限/所有权进行匹配
当前目录下搜索出权限为777的文件

find . -type f -perm 777
找出当前目录下权限不是644的php文件

find . -type f -name &quot;*.php&quot; ! -perm 644
找出当前目录用户tom拥有的所有文件

find . -type f -user tom
找出当前目录用户组sunk拥有的所有文件

find . -type f -group sunk
借助-exec选项与其他命令结合使用
找出当前目录下所有root的文件，并把所有权更改为用户tom

find .-type f -user root -exec chown tom {} \;
上例中，{} 用于与-exec选项结合使用来匹配所有文件，然后会被替换为相应的文件名。

找出自己家目录下所有的.txt文件并删除

find $HOME/. -name &quot;*.txt&quot; -ok rm {} \;
上例中，-ok和-exec行为一样，不过它会给出提示，是否执行相应的操作。

查找当前目录下所有.txt文件并把他们拼接起来写入到all.txt文件中

find . -type f -name &quot;*.txt&quot; -exec cat {} \;&gt; all.txt
将30天前的.log文件移动到old目录中

find . -type f -mtime +30 -name &quot;*.log&quot; -exec cp {} old \;
找出当前目录下所有.txt文件并以“File:文件名”的形式打印出来

find . -type f -name &quot;*.txt&quot; -exec printf &quot;File: %s\n&quot; {} \;
因为单行命令中-exec参数中无法使用多个命令，以下方法可以实现在-exec之后接受多条命令

-exec ./text.sh {} \;
搜索但跳出指定的目录
查找当前目录或者子目录下所有.txt文件，但是跳过子目录sk

find . -path &quot;./sk&quot; -prune -o -name &quot;*.txt&quot; -print
find其他技巧收集
要列出所有长度为零的文件

find . -empty
</code></pre>
		</div>
		<footer class="post__footer">
			
<div class="post__tags tags clearfix">
	<svg class="tags__badge icon icon-tag" width="16" height="16" viewBox="0 0 32 32"><path d="M32 19c0 1-1 2-1 2L21 31s-1 1-2 1-2-1-2-1L2 16c-1-1-1.4-2-1.4-2S0 12.5 0 11V3C0 1.5.8.8.8.8S1.5 0 3 0h8c1.5 0 3 .6 3 .6S15 1 16 2l15 15s1 1 1 2zM7 10a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/></svg>
	<ul class="tags__list">
		<li class="tags__item"><a class="tags__link btn" href="/tags/mac/" rel="tag">mac</a></li>
		<li class="tags__item"><a class="tags__link btn" href="/tags/%E6%8A%80%E5%B7%A7/" rel="tag">技巧</a></li>
	</ul>
</div>
		</footer>
	</article>
</main>


<nav class="post-nav flex">
	<div class="post-nav__item post-nav__item--prev">
		<a class="post-nav__link" href="/post/node_npm/" rel="prev"><span class="post-nav__caption">«&thinsp;上一篇</span><p class="post-nav__post-title">转载:npm安装包失败 npm国内镜像</p></a>
	</div>
	<div class="post-nav__item post-nav__item--next">
		<a class="post-nav__link" href="/post/wget/" rel="next"><span class="post-nav__caption">下一篇&thinsp;»</span><p class="post-nav__post-title">如何通过命令行使用wget批量下载文件</p></a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2019 TecX.
			<span class="footer__copyright-credits">基于 <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> 引擎和 <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a>主題</span>
		</div>
	</div>
</footer>
	</div>
<script async defer src="/js/menu.js"></script>
<script src="/js/custom.js"></script></body>
</html>